Рассмотрим пример, который демонстрирует ключевые особенности артефактов и типичные сценарии их использования в Google ADK, используя выдуманный "Агент по обработке изображений".

---

**Пример: Агент по обработке изображений в ADK**

Представим, что у нас есть агент, который может получать изображения от пользователя, применять к ним различные фильтры и сохранять обработанные версии.

**Действующие лица:**

* **`ImageProcessingAgent`**: Агент, который управляет логикой обработки изображений.
* **`ImageTool`**: Инструмент, который выполняет фактические операции обработки изображений (например, "apply\_grayscale", "resize\_image").
* **Пользователь**: Загружает изображения и запрашивает их обработку.

**Сценарий использования: Пользователь загружает изображение и просит применить черно-белый фильтр.**

**Последовательность событий и использование артефактов:**

1.  **Пользователь загружает изображение (Сценарий использования: Загрузка медиафайлов):**
    * **Действие:** Пользователь отправляет запрос с прикрепленным изображением.
    * **Событие (Event):** `Runner` создает событие от имени пользователя, которое включает в себя артефакт.
        ```json
        {
            "author": "user",
            "content": {
                "parts": [
                    {"text": "Примени черно-белый фильтр к этому изображению:"},
                    {
                        "inline_data": {
                            "mime_type": "image/png",
                            "data": "iVBORw0KGgoAAAANSUhEUgAAA... (base64 кодированные данные изображения)"
                        },
                        "artifact_name": "uploaded_image_original.png" // <--- Ключевая особенность: Имя файла
                    }
                ]
            },
            "actions": {
                "artifact_delta": {
                    "uploaded_image_original.png": { // <--- Ключевая особенность: Управление через события (artifact_delta)
                        "data": "iVBORw0KGgoAAAANSUhEUgAAA... (base64 данные)",
                        "mime_type": "image/png"
                    }
                }
            },
            "invocation_id": "..."
        }
        ```
    * **Что происходит в Event Loop:** `Runner` получает это событие. `Artifact Service` (благодаря `artifact_delta`) сохраняет `uploaded_image_original.png` в хранилище артефактов. Затем `Runner` передает событие `ImageProcessingAgent`.

2.  **Агент запрашивает использование инструмента для обработки изображения (Сценарий использования: Обработка изображений):**
    * **Действие:** `ImageProcessingAgent` анализирует запрос пользователя, видит прикрепленное изображение и понимает, что нужно применить фильтр. Он *выдает* (yields) событие, запрашивающее выполнение инструмента.
    * **Событие (Event):**
        ```json
        {
            "author": "ImageProcessingAgent",
            "invocation_id": "...",
            "function_calls": [{
                "name": "apply_grayscale",
                "args": {
                    "image_name": "uploaded_image_original.png", // <--- Передача имени артефакта как аргумента
                    "output_name": "uploaded_image_grayscale.png" // <--- Указание имени для нового артефакта
                }
            }]
        }
        ```
    * **Что происходит в Event Loop:** `Runner` получает этот запрос `function_call`. Он находит и вызывает `ImageTool.apply_grayscale`, передавая ему имя файла `uploaded_image_original.png`. `ImageTool` получает бинарные данные этого артефакта из `Artifact Service`, обрабатывает их и сохраняет результат.

3.  **Инструмент возвращает результат обработки и создает новый артефакт (Сценарий использования: Генерируемые отчеты/файлы):**
    * **Действие:** `ImageTool.apply_grayscale` завершает свою работу. Он создает новое черно-белое изображение и сохраняет его как новый артефакт.
    * **Событие (Event):** Фреймворк генерирует событие с результатом выполнения функции.
        ```json
        {
            "author": "ImageProcessingAgent", // Автор здесь может быть агентом, который запросил инструмент
            "invocation_id": "...",
            "function_responses": [{
                "name": "apply_grayscale",
                "response": {
                    "status": "success",
                    "message": "Grayscale filter applied successfully."
                }
            }],
            "actions": {
                "artifact_delta": { // <--- Ключевая особенность: Управление через события (artifact_delta)
                    "uploaded_image_grayscale.png": { // <--- Создан новый артефакт
                        "data": "iVBORw0KGgoAAAANSUhEUgAAA... (base64 кодированные данные черно-белого изображения)",
                        "mime_type": "image/png"
                    }
                }
            }
        }
        ```
    * **Что происходит в Event Loop:** `Runner` получает это событие. `Artifact Service` сохраняет `uploaded_image_grayscale.png`. `Runner` передает это событие обратно `ImageProcessingAgent`.

4.  **Агент отправляет ответ пользователю, ссылаясь на новый артефакт:**
    * **Действие:** `ImageProcessingAgent` получает подтверждение об успешной обработке и формирует ответ для пользователя, который включает ссылку на обработанное изображение.
    * **Событие (Event):**
        ```json
        {
            "author": "ImageProcessingAgent",
            "invocation_id": "...",
            "content": {
                "parts": [
                    {"text": "Вот ваше изображение с черно-белым фильтром:"},
                    {
                        "artifact_name": "uploaded_image_grayscale.png" // <--- Ключевая особенность: Единообразное представление (ссылка на артефакт)
                    }
                ]
            }
        }
        ```
    * **Что происходит в Event Loop:** `Runner` получает это финальное событие и отправляет его пользовательскому интерфейсу. Пользовательский интерфейс использует `artifact_name`, чтобы запросить `uploaded_image_grayscale.png` из `Artifact Service` и отобразить его пользователю.

**Демонстрация Ключевых Особенностей Артефактов:**

* **Бинарные данные:** Исходное изображение и обработанное черно-белое изображение являются бинарными данными (PNG).
* **Имя файла (`artifact_name`):** Изображения идентифицируются уникальными именами файлов: `uploaded_image_original.png` и `uploaded_image_grayscale.png`.
* **Версионирование (неявно в этом примере, но важно):** Если бы мы вызвали `apply_grayscale` еще раз на `uploaded_image_original.png`, но с другим именем вывода, или даже с тем же именем, но с другой реализацией инструмента, `Artifact Service` мог бы создать новую версию, позволяя отслеживать изменения. (В данном примере, поскольку мы создали новое имя, версионирование явно не демонстрируется для *одного и того же* файла, но возможность есть).
* **Единообразное представление (`google.genai.types.Part` и `artifact_name`):** Как входные, так и выходные данные изображения представлены как `Part` с использованием `inline_data` или ссылки на `artifact_name`.
* **Сервис артефактов (`Artifact Service`):** Фоновая служба, которая неявно управляет сохранением и извлечением `uploaded_image_original.png` и `uploaded_image_grayscale.png`.
* **Область видимости (`Scope` - по умолчанию сессия):** Оба артефакта доступны в рамках текущей сессии пользователя. Если бы пользователь начал новую сессию, эти артефакты по умолчанию не были бы доступны (если не настроена пользовательская область видимости).
* **Управление через события (`artifact_delta`):** Добавление нового артефакта в систему явно сигнализируется через `artifact_delta` в событиях.

**Демонстрация Типичных Сценариев Использования:**

* **Загрузка медиафайлов:** Пользователь загружает изображение как входные данные для агента.
* **Обработка изображений:** Агент инициирует сложную операцию обработки изображения, используя инструмент.
* **Генерируемые отчеты/файлы:** Инструмент генерирует новый бинарный файл (обработанное изображение) и делает его доступным для пользователя.

Этот пример показывает, как артефакты органично вписываются в событийно-ориентированную архитектуру ADK, позволяя агентам эффективно управлять и обмениваться бинарными данными на протяжении всего взаимодействия.
